### Plan for Enhanced Anki Tagging

This plan outlines the implementation of a more flexible and comprehensive tagging system for Anki notes, integrating tags from multiple sources: script-generated, data source-specific metadata, and command-line arguments.

**Objective:**
To allow users to automatically apply descriptive and functional tags to Anki notes based on the origin of the learning item, improving organization and study filtering capabilities.

**Tag Structure (using Anki's nested tag format `Parent::Child`):**

*   **Time**: `Year::YYYY`, `Month::MM` (automatically generated by script)
*   **Source Type**: `Type::Book`, `Type::News`, `Type::Email`, `Type::Slack`, `Type::Todoist`, `Type::CSV`, `Type::TextFile` (derived from data source, or can be user-defined)
*   **Specific Source**: `Source::Book_Title`, `Source::News_Outlet`, `Source::Email_Domain`, `Source::Slack_Channel` (derived from data source, or can be user-defined)
*   **Subject/Domain**: `Topic::Technology`, `Topic::Finance`, `Topic::Literature` (user-defined)
*   **Functional Tags**: `Check`, `Idiom`, `PhrasalVerb`, `Critical` (user-defined)

---

**Implementation Steps:**

**1. Update `SourceSentence` Domain Model (`domain/models.py`)**
    *   Add an optional `tags: Optional[List[str]] = field(default_factory=list)` field to the `SourceSentence` dataclass. This will allow data sources to provide initial tags.

**2. Modify `SentenceSource` Implementations:**

    **a. `TodoistSentenceSource` (`datasources/todoist_source.py`)**
        *   Modify `fetch_sentences` to extract existing Todoist task labels (`task.labels`). Convert these labels into a consistent tag format (e.g., `TaskLabel::MyLabel`).
        *   Add a default `Type::Todoist` tag to each `SourceSentence`.

    **b. `CsvSentenceSource` (`datasources/csv_source.py`)**
        *   Modify the expected CSV header to include an optional `tags` column.
        *   If the `tags` column exists, parse its comma-separated values into a list of strings and add them to the `SourceSentence` object.
        *   Add a default `Type::CSV` tag.

    **c. `TextFileSentenceSource` (`datasources/text_file_source.py`)**
        *   For simplicity initially, tags will be provided via command-line arguments for this source type.
        *   Add a default `Type::TextFile` tag.

**3. Update `main.py` (Composition Root and `run_process` function):**

    **a. `run_process` Function:**
        *   Modify the function signature to accept an additional `cli_tags: Optional[List[str]] = None` parameter.
        *   Combine script-generated tags (`Year::`, `Month::`), `item.tags` (from data source), and `cli_tags` into a final list of tags passed to `anki_service.add_note`. Ensure uniqueness and proper formatting of nested tags.
        *   The `Source::` tag should be generated from `item.entry_text` if `item.entry_text` does not just contain the learning word (i.e. if it's "english headspace", the tag could be `Source::EnglishHeadspace`). This would require some sanitization (replacing spaces with underscores, removing special chars). If `item.entry_text` just contains the learning word, this tag might be skipped or generated differently. For now, let's keep `Source::` tags purely user-defined via CLI/CSV for simplicity.

    **b. `main` Function:**
        *   Add a new command-line argument: `--tags` (`-t`), which accepts comma-separated tags (e.g., `--tags "Topic::Literature,Critical"`).
        *   Parse these tags and pass them as `cli_tags` to `run_process`.

**4. Update `anki_service.py`:**
    *   Ensure `add_note` properly handles the `tags` list (it already does, but just a final check).

**5. Update `GEMINI.md`:**
    *   Add documentation for the new tagging system, including tag types, structure, and usage with command-line arguments and data sources.

**6. Update `tests/test_main.py`:**
    *   Modify existing mocks for `SentenceSource` to include `tags` in `SourceSentence` objects (for Todoist and CSV).
    *   Modify mock `argparse` to include `--tags` argument.
    *   Add new assertions to verify:
        *   Combination of script-generated, source-provided, and command-line tags.
        *   Correct formatting of nested tags.
        *   Handling of duplicate tags (ensuring they are unique when combined).
